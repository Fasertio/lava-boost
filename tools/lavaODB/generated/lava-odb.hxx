// This file was generated by ODB, object-relational mapping (ORM)
// compiler for C++.
//

#ifndef LAVA_ODB_HXX
#define LAVA_ODB_HXX

#include <odb/version.hxx>

#if (ODB_VERSION != 20400UL)
#error ODB runtime version mismatch
#endif

#include <odb/pre.hxx>

#include "lava.hxx"

#include <memory>
#include <cstddef>
#include <utility>

#include <odb/core.hxx>
#include <odb/traits.hxx>
#include <odb/callback.hxx>
#include <odb/wrapper-traits.hxx>
#include <odb/pointer-traits.hxx>
#include <odb/container-traits.hxx>
#include <odb/no-op-cache-traits.hxx>
#include <odb/prepared-query.hxx>
#include <odb/result.hxx>
#include <odb/simple-object-result.hxx>
#include <odb/view-image.hxx>
#include <odb/view-result.hxx>

#include <odb/details/unused.hxx>
#include <odb/details/shared-ptr.hxx>

namespace odb
{
  // SourceLval
  //
  template <>
  struct class_traits< ::SourceLval >
  {
    static const class_kind kind = class_object;
  };

  template <>
  class access::object_traits< ::SourceLval >
  {
    public:
    typedef ::SourceLval object_type;
    typedef ::SourceLval* pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef ::uint64_t id_type;

    static const bool auto_id = true;

    static const bool abstract = false;

    static id_type
    id (const object_type&);

    typedef
    no_op_pointer_cache_traits<pointer_type>
    pointer_cache_traits;

    typedef
    no_op_reference_cache_traits<object_type>
    reference_cache_traits;

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);
  };

  // LabelSet
  //
  template <>
  struct class_traits< ::LabelSet >
  {
    static const class_kind kind = class_object;
  };

  template <>
  class access::object_traits< ::LabelSet >
  {
    public:
    typedef ::LabelSet object_type;
    typedef ::LabelSet* pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef ::uint64_t id_type;

    static const bool auto_id = true;

    static const bool abstract = false;

    static id_type
    id (const object_type&);

    typedef
    no_op_pointer_cache_traits<pointer_type>
    pointer_cache_traits;

    typedef
    no_op_reference_cache_traits<object_type>
    reference_cache_traits;

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);
  };

  // Dua
  //
  template <>
  struct class_traits< ::Dua >
  {
    static const class_kind kind = class_object;
  };

  template <>
  class access::object_traits< ::Dua >
  {
    public:
    typedef ::Dua object_type;
    typedef ::Dua* pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef ::uint64_t id_type;

    static const bool auto_id = true;

    static const bool abstract = false;

    static id_type
    id (const object_type&);

    typedef
    no_op_pointer_cache_traits<pointer_type>
    pointer_cache_traits;

    typedef
    no_op_reference_cache_traits<object_type>
    reference_cache_traits;

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);
  };

  // DuaBytes
  //
  template <>
  struct class_traits< ::DuaBytes >
  {
    static const class_kind kind = class_object;
  };

  template <>
  class access::object_traits< ::DuaBytes >
  {
    public:
    typedef ::DuaBytes object_type;
    typedef ::DuaBytes* pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef ::uint64_t id_type;

    static const bool auto_id = true;

    static const bool abstract = false;

    static id_type
    id (const object_type&);

    typedef
    no_op_pointer_cache_traits<pointer_type>
    pointer_cache_traits;

    typedef
    no_op_reference_cache_traits<object_type>
    reference_cache_traits;

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);
  };

  // AttackPoint
  //
  template <>
  struct class_traits< ::AttackPoint >
  {
    static const class_kind kind = class_object;
  };

  template <>
  class access::object_traits< ::AttackPoint >
  {
    public:
    typedef ::AttackPoint object_type;
    typedef ::AttackPoint* pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef ::uint64_t id_type;

    static const bool auto_id = true;

    static const bool abstract = false;

    static id_type
    id (const object_type&);

    typedef
    no_op_pointer_cache_traits<pointer_type>
    pointer_cache_traits;

    typedef
    no_op_reference_cache_traits<object_type>
    reference_cache_traits;

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);
  };

  // Bug
  //
  template <>
  struct class_traits< ::Bug >
  {
    static const class_kind kind = class_object;
  };

  template <>
  class access::object_traits< ::Bug >
  {
    public:
    typedef ::Bug object_type;
    typedef ::Bug* pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef ::uint64_t id_type;

    static const bool auto_id = true;

    static const bool abstract = false;

    static id_type
    id (const object_type&);

    typedef
    no_op_pointer_cache_traits<pointer_type>
    pointer_cache_traits;

    typedef
    no_op_reference_cache_traits<object_type>
    reference_cache_traits;

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);
  };

  // BugLval
  //
  template <>
  struct class_traits< ::BugLval >
  {
    static const class_kind kind = class_view;
  };

  template <>
  class access::view_traits< ::BugLval >
  {
    public:
    typedef ::BugLval view_type;
    typedef ::BugLval* pointer_type;

    static void
    callback (database&, view_type&, callback_event);
  };

  // Build
  //
  template <>
  struct class_traits< ::Build >
  {
    static const class_kind kind = class_object;
  };

  template <>
  class access::object_traits< ::Build >
  {
    public:
    typedef ::Build object_type;
    typedef ::Build* pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef ::uint64_t id_type;

    static const bool auto_id = true;

    static const bool abstract = false;

    static id_type
    id (const object_type&);

    typedef
    no_op_pointer_cache_traits<pointer_type>
    pointer_cache_traits;

    typedef
    no_op_reference_cache_traits<object_type>
    reference_cache_traits;

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);
  };

  // Run
  //
  template <>
  struct class_traits< ::Run >
  {
    static const class_kind kind = class_object;
  };

  template <>
  class access::object_traits< ::Run >
  {
    public:
    typedef ::Run object_type;
    typedef ::Run* pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef ::uint64_t id_type;

    static const bool auto_id = true;

    static const bool abstract = false;

    static id_type
    id (const object_type&);

    typedef
    no_op_pointer_cache_traits<pointer_type>
    pointer_cache_traits;

    typedef
    no_op_reference_cache_traits<object_type>
    reference_cache_traits;

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);
  };

  // SourceFunction
  //
  template <>
  struct class_traits< ::SourceFunction >
  {
    static const class_kind kind = class_object;
  };

  template <>
  class access::object_traits< ::SourceFunction >
  {
    public:
    typedef ::SourceFunction object_type;
    typedef ::SourceFunction* pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef ::uint64_t id_type;

    static const bool auto_id = true;

    static const bool abstract = false;

    static id_type
    id (const object_type&);

    typedef
    no_op_pointer_cache_traits<pointer_type>
    pointer_cache_traits;

    typedef
    no_op_reference_cache_traits<object_type>
    reference_cache_traits;

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);
  };

  // Call
  //
  template <>
  struct class_traits< ::Call >
  {
    static const class_kind kind = class_object;
  };

  template <>
  class access::object_traits< ::Call >
  {
    public:
    typedef ::Call object_type;
    typedef ::Call* pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef ::uint64_t id_type;

    static const bool auto_id = true;

    static const bool abstract = false;

    static id_type
    id (const object_type&);

    typedef
    no_op_pointer_cache_traits<pointer_type>
    pointer_cache_traits;

    typedef
    no_op_reference_cache_traits<object_type>
    reference_cache_traits;

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);
  };
}

#include <odb/details/buffer.hxx>

#include <odb/pgsql/version.hxx>
#include <odb/pgsql/forward.hxx>
#include <odb/pgsql/binding.hxx>
#include <odb/pgsql/pgsql-types.hxx>
#include <odb/pgsql/query.hxx>

namespace odb
{
  // Loc
  //
  template <>
  class access::composite_value_traits< ::Loc, id_pgsql >
  {
    public:
    typedef ::Loc value_type;

    struct image_type
    {
      // line
      //
      int line_value;
      bool line_null;

      // column
      //
      int column_value;
      bool column_null;
    };

    static bool
    grow (image_type&,
          bool*);

    static void
    bind (pgsql::bind*,
          image_type&,
          pgsql::statement_kind);

    static bool
    init (image_type&,
          const value_type&,
          pgsql::statement_kind);

    static void
    init (value_type&,
          const image_type&,
          database*);

    static bool
    get_null (const image_type&);

    static void
    set_null (image_type&,
              pgsql::statement_kind);

    static const std::size_t column_count = 2UL;
  };

  // LavaASTLoc
  //
  template <>
  class access::composite_value_traits< ::LavaASTLoc, id_pgsql >
  {
    public:
    typedef ::LavaASTLoc value_type;

    struct image_type
    {
      // filename
      //
      details::buffer filename_value;
      std::size_t filename_size;
      bool filename_null;

      // begin
      //
      composite_value_traits< ::Loc, id_pgsql >::image_type begin_value;

      // end
      //
      composite_value_traits< ::Loc, id_pgsql >::image_type end_value;
    };

    static bool
    grow (image_type&,
          bool*);

    static void
    bind (pgsql::bind*,
          image_type&,
          pgsql::statement_kind);

    static bool
    init (image_type&,
          const value_type&,
          pgsql::statement_kind);

    static void
    init (value_type&,
          const image_type&,
          database*);

    static bool
    get_null (const image_type&);

    static void
    set_null (image_type&,
              pgsql::statement_kind);

    static const std::size_t column_count = 5UL;
  };

  // Range
  //
  template <>
  class access::composite_value_traits< ::Range, id_pgsql >
  {
    public:
    typedef ::Range value_type;

    struct image_type
    {
      // low
      //
      int low_value;
      bool low_null;

      // high
      //
      int high_value;
      bool high_null;
    };

    static bool
    grow (image_type&,
          bool*);

    static void
    bind (pgsql::bind*,
          image_type&,
          pgsql::statement_kind);

    static bool
    init (image_type&,
          const value_type&,
          pgsql::statement_kind);

    static void
    init (value_type&,
          const image_type&,
          database*);

    static bool
    get_null (const image_type&);

    static void
    set_null (image_type&,
              pgsql::statement_kind);

    static const std::size_t column_count = 2UL;
  };

  // SourceLval
  //
  template <typename A>
  struct query_columns< ::SourceLval, id_pgsql, A >
  {
    // id
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint64_t,
        pgsql::id_bigint >::query_type,
      pgsql::id_bigint >
    id_type_;

    static const id_type_ id;

    // loc
    //
    struct loc_class_
    {
      loc_class_ ()
      {
      }

      // filename
      //
      typedef
      pgsql::query_column<
        pgsql::value_traits<
          ::std::string,
          pgsql::id_string >::query_type,
        pgsql::id_string >
      filename_type_;

      static const filename_type_ filename;

      // begin
      //
      struct begin_class_1_
      {
        begin_class_1_ ()
        {
        }

        // line
        //
        typedef
        pgsql::query_column<
          pgsql::value_traits<
            ::uint32_t,
            pgsql::id_integer >::query_type,
          pgsql::id_integer >
        line_type_;

        static const line_type_ line;

        // column
        //
        typedef
        pgsql::query_column<
          pgsql::value_traits<
            ::uint32_t,
            pgsql::id_integer >::query_type,
          pgsql::id_integer >
        column_type_;

        static const column_type_ column;
      };

      static const begin_class_1_ begin;

      // end
      //
      struct end_class_1_
      {
        end_class_1_ ()
        {
        }

        // line
        //
        typedef
        pgsql::query_column<
          pgsql::value_traits<
            ::uint32_t,
            pgsql::id_integer >::query_type,
          pgsql::id_integer >
        line_type_;

        static const line_type_ line;

        // column
        //
        typedef
        pgsql::query_column<
          pgsql::value_traits<
            ::uint32_t,
            pgsql::id_integer >::query_type,
          pgsql::id_integer >
        column_type_;

        static const column_type_ column;
      };

      static const end_class_1_ end;
    };

    static const loc_class_ loc;

    // ast_name
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::std::string,
        pgsql::id_string >::query_type,
      pgsql::id_string >
    ast_name_type_;

    static const ast_name_type_ ast_name;

    // len_bytes
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint32_t,
        pgsql::id_integer >::query_type,
      pgsql::id_integer >
    len_bytes_type_;

    static const len_bytes_type_ len_bytes;
  };

  template <typename A>
  const typename query_columns< ::SourceLval, id_pgsql, A >::id_type_
  query_columns< ::SourceLval, id_pgsql, A >::
  id (A::table_name, "\"id\"", 0);

  template <typename A>
  const typename query_columns< ::SourceLval, id_pgsql, A >::loc_class_::filename_type_
  query_columns< ::SourceLval, id_pgsql, A >::loc_class_::
  filename (A::table_name, "\"loc_filename\"", 0);

  template <typename A>
  const typename query_columns< ::SourceLval, id_pgsql, A >::loc_class_::begin_class_1_::line_type_
  query_columns< ::SourceLval, id_pgsql, A >::loc_class_::begin_class_1_::
  line (A::table_name, "\"loc_begin_line\"", 0);

  template <typename A>
  const typename query_columns< ::SourceLval, id_pgsql, A >::loc_class_::begin_class_1_::column_type_
  query_columns< ::SourceLval, id_pgsql, A >::loc_class_::begin_class_1_::
  column (A::table_name, "\"loc_begin_column\"", 0);

  template <typename A>
  const typename query_columns< ::SourceLval, id_pgsql, A >::loc_class_::begin_class_1_
  query_columns< ::SourceLval, id_pgsql, A >::loc_class_::begin;

  template <typename A>
  const typename query_columns< ::SourceLval, id_pgsql, A >::loc_class_::end_class_1_::line_type_
  query_columns< ::SourceLval, id_pgsql, A >::loc_class_::end_class_1_::
  line (A::table_name, "\"loc_end_line\"", 0);

  template <typename A>
  const typename query_columns< ::SourceLval, id_pgsql, A >::loc_class_::end_class_1_::column_type_
  query_columns< ::SourceLval, id_pgsql, A >::loc_class_::end_class_1_::
  column (A::table_name, "\"loc_end_column\"", 0);

  template <typename A>
  const typename query_columns< ::SourceLval, id_pgsql, A >::loc_class_::end_class_1_
  query_columns< ::SourceLval, id_pgsql, A >::loc_class_::end;

  template <typename A>
  const typename query_columns< ::SourceLval, id_pgsql, A >::loc_class_
  query_columns< ::SourceLval, id_pgsql, A >::loc;

  template <typename A>
  const typename query_columns< ::SourceLval, id_pgsql, A >::ast_name_type_
  query_columns< ::SourceLval, id_pgsql, A >::
  ast_name (A::table_name, "\"ast_name\"", 0);

  template <typename A>
  const typename query_columns< ::SourceLval, id_pgsql, A >::len_bytes_type_
  query_columns< ::SourceLval, id_pgsql, A >::
  len_bytes (A::table_name, "\"len_bytes\"", 0);

  template <typename A>
  struct pointer_query_columns< ::SourceLval, id_pgsql, A >:
    query_columns< ::SourceLval, id_pgsql, A >
  {
  };

  template <>
  class access::object_traits_impl< ::SourceLval, id_pgsql >:
    public access::object_traits< ::SourceLval >
  {
    public:
    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    struct image_type
    {
      // id
      //
      long long id_value;
      bool id_null;

      // loc
      //
      composite_value_traits< ::LavaASTLoc, id_pgsql >::image_type loc_value;

      // ast_name
      //
      details::buffer ast_name_value;
      std::size_t ast_name_size;
      bool ast_name_null;

      // len_bytes
      //
      int len_bytes_value;
      bool len_bytes_null;

      std::size_t version;
    };

    struct extra_statement_cache_type;

    using object_traits<object_type>::id;

    static id_type
    id (const id_image_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&,
          bool*);

    static void
    bind (pgsql::bind*,
          image_type&,
          pgsql::statement_kind);

    static void
    bind (pgsql::bind*, id_image_type&);

    static bool
    init (image_type&,
          const object_type&,
          pgsql::statement_kind);

    static void
    init (object_type&,
          const image_type&,
          database*);

    static void
    init (id_image_type&, const id_type&);

    typedef pgsql::object_statements<object_type> statements_type;

    typedef pgsql::query_base query_base_type;

    static const std::size_t column_count = 8UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const std::size_t separate_load_column_count = 0UL;
    static const std::size_t separate_update_column_count = 0UL;

    static const bool versioned = false;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static odb::details::shared_ptr<prepared_query_impl>
    prepare_query (connection&, const char*, const query_base_type&);

    static odb::details::shared_ptr<result_impl>
    execute_query (prepared_query_impl&);

    static const char persist_statement_name[];
    static const char find_statement_name[];
    static const char update_statement_name[];
    static const char erase_statement_name[];
    static const char query_statement_name[];
    static const char erase_query_statement_name[];

    static const unsigned int persist_statement_types[];
    static const unsigned int find_statement_types[];
    static const unsigned int update_statement_types[];

    public:
    static bool
    find_ (statements_type&,
           const id_type*);

    static void
    load_ (statements_type&,
           object_type&,
           bool reload);
  };

  template <>
  class access::object_traits_impl< ::SourceLval, id_common >:
    public access::object_traits_impl< ::SourceLval, id_pgsql >
  {
  };

  // LabelSet
  //
  template <typename A>
  struct query_columns< ::LabelSet, id_pgsql, A >
  {
    // id
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint64_t,
        pgsql::id_bigint >::query_type,
      pgsql::id_bigint >
    id_type_;

    static const id_type_ id;

    // ptr
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint64_t,
        pgsql::id_bigint >::query_type,
      pgsql::id_bigint >
    ptr_type_;

    static const ptr_type_ ptr;

    // inputfile
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::std::string,
        pgsql::id_string >::query_type,
      pgsql::id_string >
    inputfile_type_;

    static const inputfile_type_ inputfile;

    // labels
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::std::vector< unsigned int >,
        pgsql::id_string >::query_type,
      pgsql::id_string >
    labels_type_;

    static const labels_type_ labels;
  };

  template <typename A>
  const typename query_columns< ::LabelSet, id_pgsql, A >::id_type_
  query_columns< ::LabelSet, id_pgsql, A >::
  id (A::table_name, "\"id\"", 0);

  template <typename A>
  const typename query_columns< ::LabelSet, id_pgsql, A >::ptr_type_
  query_columns< ::LabelSet, id_pgsql, A >::
  ptr (A::table_name, "\"ptr\"", 0);

  template <typename A>
  const typename query_columns< ::LabelSet, id_pgsql, A >::inputfile_type_
  query_columns< ::LabelSet, id_pgsql, A >::
  inputfile (A::table_name, "\"inputfile\"", 0);

  template <typename A>
  const typename query_columns< ::LabelSet, id_pgsql, A >::labels_type_
  query_columns< ::LabelSet, id_pgsql, A >::
  labels (A::table_name, "\"labels\"", "(?)::INTEGER[]");

  template <typename A>
  struct pointer_query_columns< ::LabelSet, id_pgsql, A >:
    query_columns< ::LabelSet, id_pgsql, A >
  {
  };

  template <>
  class access::object_traits_impl< ::LabelSet, id_pgsql >:
    public access::object_traits< ::LabelSet >
  {
    public:
    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    struct image_type
    {
      // id
      //
      long long id_value;
      bool id_null;

      // ptr
      //
      long long ptr_value;
      bool ptr_null;

      // inputfile
      //
      details::buffer inputfile_value;
      std::size_t inputfile_size;
      bool inputfile_null;

      // labels
      //
      details::buffer labels_value;
      std::size_t labels_size;
      bool labels_null;

      std::size_t version;
    };

    struct extra_statement_cache_type;

    using object_traits<object_type>::id;

    static id_type
    id (const id_image_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&,
          bool*);

    static void
    bind (pgsql::bind*,
          image_type&,
          pgsql::statement_kind);

    static void
    bind (pgsql::bind*, id_image_type&);

    static bool
    init (image_type&,
          const object_type&,
          pgsql::statement_kind);

    static void
    init (object_type&,
          const image_type&,
          database*);

    static void
    init (id_image_type&, const id_type&);

    typedef pgsql::object_statements<object_type> statements_type;

    typedef pgsql::query_base query_base_type;

    static const std::size_t column_count = 4UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const std::size_t separate_load_column_count = 0UL;
    static const std::size_t separate_update_column_count = 0UL;

    static const bool versioned = false;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static odb::details::shared_ptr<prepared_query_impl>
    prepare_query (connection&, const char*, const query_base_type&);

    static odb::details::shared_ptr<result_impl>
    execute_query (prepared_query_impl&);

    static const char persist_statement_name[];
    static const char find_statement_name[];
    static const char update_statement_name[];
    static const char erase_statement_name[];
    static const char query_statement_name[];
    static const char erase_query_statement_name[];

    static const unsigned int persist_statement_types[];
    static const unsigned int find_statement_types[];
    static const unsigned int update_statement_types[];

    public:
    static bool
    find_ (statements_type&,
           const id_type*);

    static void
    load_ (statements_type&,
           object_type&,
           bool reload);
  };

  template <>
  class access::object_traits_impl< ::LabelSet, id_common >:
    public access::object_traits_impl< ::LabelSet, id_pgsql >
  {
  };

  // Dua
  //
  template <typename A>
  struct pointer_query_columns< ::Dua, id_pgsql, A >
  {
    // id
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint64_t,
        pgsql::id_bigint >::query_type,
      pgsql::id_bigint >
    id_type_;

    static const id_type_ id;

    // lval
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint64_t,
        pgsql::id_bigint >::query_type,
      pgsql::id_bigint >
    lval_type_;

    static const lval_type_ lval;

    // byte_tcn
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::std::vector< unsigned int >,
        pgsql::id_string >::query_type,
      pgsql::id_string >
    byte_tcn_type_;

    static const byte_tcn_type_ byte_tcn;

    // all_labels
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::std::vector< unsigned int >,
        pgsql::id_string >::query_type,
      pgsql::id_string >
    all_labels_type_;

    static const all_labels_type_ all_labels;

    // inputfile
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::std::string,
        pgsql::id_string >::query_type,
      pgsql::id_string >
    inputfile_type_;

    static const inputfile_type_ inputfile;

    // max_tcn
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint32_t,
        pgsql::id_integer >::query_type,
      pgsql::id_integer >
    max_tcn_type_;

    static const max_tcn_type_ max_tcn;

    // max_cardinality
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint32_t,
        pgsql::id_integer >::query_type,
      pgsql::id_integer >
    max_cardinality_type_;

    static const max_cardinality_type_ max_cardinality;

    // instr
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint64_t,
        pgsql::id_bigint >::query_type,
      pgsql::id_bigint >
    instr_type_;

    static const instr_type_ instr;

    // fake_dua
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        bool,
        pgsql::id_boolean >::query_type,
      pgsql::id_boolean >
    fake_dua_type_;

    static const fake_dua_type_ fake_dua;
  };

  template <typename A>
  const typename pointer_query_columns< ::Dua, id_pgsql, A >::id_type_
  pointer_query_columns< ::Dua, id_pgsql, A >::
  id (A::table_name, "\"id\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::Dua, id_pgsql, A >::lval_type_
  pointer_query_columns< ::Dua, id_pgsql, A >::
  lval (A::table_name, "\"lval\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::Dua, id_pgsql, A >::byte_tcn_type_
  pointer_query_columns< ::Dua, id_pgsql, A >::
  byte_tcn (A::table_name, "\"byte_tcn\"", "(?)::INTEGER[]");

  template <typename A>
  const typename pointer_query_columns< ::Dua, id_pgsql, A >::all_labels_type_
  pointer_query_columns< ::Dua, id_pgsql, A >::
  all_labels (A::table_name, "\"all_labels\"", "(?)::INTEGER[]");

  template <typename A>
  const typename pointer_query_columns< ::Dua, id_pgsql, A >::inputfile_type_
  pointer_query_columns< ::Dua, id_pgsql, A >::
  inputfile (A::table_name, "\"inputfile\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::Dua, id_pgsql, A >::max_tcn_type_
  pointer_query_columns< ::Dua, id_pgsql, A >::
  max_tcn (A::table_name, "\"max_tcn\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::Dua, id_pgsql, A >::max_cardinality_type_
  pointer_query_columns< ::Dua, id_pgsql, A >::
  max_cardinality (A::table_name, "\"max_cardinality\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::Dua, id_pgsql, A >::instr_type_
  pointer_query_columns< ::Dua, id_pgsql, A >::
  instr (A::table_name, "\"instr\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::Dua, id_pgsql, A >::fake_dua_type_
  pointer_query_columns< ::Dua, id_pgsql, A >::
  fake_dua (A::table_name, "\"fake_dua\"", 0);

  template <>
  class access::object_traits_impl< ::Dua, id_pgsql >:
    public access::object_traits< ::Dua >
  {
    public:
    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    struct image_type
    {
      // id
      //
      long long id_value;
      bool id_null;

      // lval
      //
      long long lval_value;
      bool lval_null;

      // byte_tcn
      //
      details::buffer byte_tcn_value;
      std::size_t byte_tcn_size;
      bool byte_tcn_null;

      // all_labels
      //
      details::buffer all_labels_value;
      std::size_t all_labels_size;
      bool all_labels_null;

      // inputfile
      //
      details::buffer inputfile_value;
      std::size_t inputfile_size;
      bool inputfile_null;

      // max_tcn
      //
      int max_tcn_value;
      bool max_tcn_null;

      // max_cardinality
      //
      int max_cardinality_value;
      bool max_cardinality_null;

      // instr
      //
      long long instr_value;
      bool instr_null;

      // fake_dua
      //
      bool fake_dua_value;
      bool fake_dua_null;

      std::size_t version;
    };

    struct extra_statement_cache_type;

    // viable_bytes
    //
    struct viable_bytes_traits
    {
      static const char select_name[];
      static const char insert_name[];
      static const char delete_name[];

      static const unsigned int insert_types[];

      static const std::size_t id_column_count = 1UL;
      static const std::size_t data_column_count = 3UL;

      static const bool versioned = false;

      static const char insert_statement[];
      static const char select_statement[];
      static const char delete_statement[];

      typedef ::std::vector< const ::LabelSet* > container_type;
      typedef
      odb::access::container_traits<container_type>
      container_traits_type;
      typedef container_traits_type::index_type index_type;
      typedef container_traits_type::value_type value_type;

      typedef ordered_functions<index_type, value_type> functions_type;
      typedef pgsql::container_statements< viable_bytes_traits > statements_type;

      struct data_image_type
      {
        // index
        //
        long long index_value;
        bool index_null;

        // value
        //
        long long value_value;
        bool value_null;

        std::size_t version;
      };

      static void
      bind (pgsql::bind*,
            const pgsql::bind* id,
            std::size_t id_size,
            data_image_type&);

      static void
      grow (data_image_type&,
            bool*);

      static void
      init (data_image_type&,
            index_type*,
            const value_type&);

      static void
      init (index_type&,
            value_type&,
            const data_image_type&,
            database*);

      static void
      insert (index_type, const value_type&, void*);

      static bool
      select (index_type&, value_type&, void*);

      static void
      delete_ (void*);

      static void
      persist (const container_type&,
               statements_type&);

      static void
      load (container_type&,
            statements_type&);

      static void
      update (const container_type&,
              statements_type&);

      static void
      erase (statements_type&);
    };

    struct lval_tag;

    using object_traits<object_type>::id;

    static id_type
    id (const id_image_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&,
          bool*);

    static void
    bind (pgsql::bind*,
          image_type&,
          pgsql::statement_kind);

    static void
    bind (pgsql::bind*, id_image_type&);

    static bool
    init (image_type&,
          const object_type&,
          pgsql::statement_kind);

    static void
    init (object_type&,
          const image_type&,
          database*);

    static void
    init (id_image_type&, const id_type&);

    typedef pgsql::object_statements<object_type> statements_type;

    typedef pgsql::query_base query_base_type;

    static const std::size_t column_count = 9UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const std::size_t separate_load_column_count = 0UL;
    static const std::size_t separate_update_column_count = 0UL;

    static const bool versioned = false;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static odb::details::shared_ptr<prepared_query_impl>
    prepare_query (connection&, const char*, const query_base_type&);

    static odb::details::shared_ptr<result_impl>
    execute_query (prepared_query_impl&);

    static const char persist_statement_name[];
    static const char find_statement_name[];
    static const char update_statement_name[];
    static const char erase_statement_name[];
    static const char query_statement_name[];
    static const char erase_query_statement_name[];

    static const unsigned int persist_statement_types[];
    static const unsigned int find_statement_types[];
    static const unsigned int update_statement_types[];

    public:
    static bool
    find_ (statements_type&,
           const id_type*);

    static void
    load_ (statements_type&,
           object_type&,
           bool reload);
  };

  template <>
  class access::object_traits_impl< ::Dua, id_common >:
    public access::object_traits_impl< ::Dua, id_pgsql >
  {
  };

  // DuaBytes
  //
  template <typename A>
  struct pointer_query_columns< ::DuaBytes, id_pgsql, A >
  {
    // id
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint64_t,
        pgsql::id_bigint >::query_type,
      pgsql::id_bigint >
    id_type_;

    static const id_type_ id;

    // dua
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint64_t,
        pgsql::id_bigint >::query_type,
      pgsql::id_bigint >
    dua_type_;

    static const dua_type_ dua;

    // selected
    //
    struct selected_class_
    {
      selected_class_ ()
      {
      }

      // low
      //
      typedef
      pgsql::query_column<
        pgsql::value_traits<
          ::uint32_t,
          pgsql::id_integer >::query_type,
        pgsql::id_integer >
      low_type_;

      static const low_type_ low;

      // high
      //
      typedef
      pgsql::query_column<
        pgsql::value_traits<
          ::uint32_t,
          pgsql::id_integer >::query_type,
        pgsql::id_integer >
      high_type_;

      static const high_type_ high;
    };

    static const selected_class_ selected;

    // all_labels
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::std::vector< unsigned int >,
        pgsql::id_string >::query_type,
      pgsql::id_string >
    all_labels_type_;

    static const all_labels_type_ all_labels;
  };

  template <typename A>
  const typename pointer_query_columns< ::DuaBytes, id_pgsql, A >::id_type_
  pointer_query_columns< ::DuaBytes, id_pgsql, A >::
  id (A::table_name, "\"id\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::DuaBytes, id_pgsql, A >::dua_type_
  pointer_query_columns< ::DuaBytes, id_pgsql, A >::
  dua (A::table_name, "\"dua\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::DuaBytes, id_pgsql, A >::selected_class_::low_type_
  pointer_query_columns< ::DuaBytes, id_pgsql, A >::selected_class_::
  low (A::table_name, "\"selected_low\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::DuaBytes, id_pgsql, A >::selected_class_::high_type_
  pointer_query_columns< ::DuaBytes, id_pgsql, A >::selected_class_::
  high (A::table_name, "\"selected_high\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::DuaBytes, id_pgsql, A >::selected_class_
  pointer_query_columns< ::DuaBytes, id_pgsql, A >::selected;

  template <typename A>
  const typename pointer_query_columns< ::DuaBytes, id_pgsql, A >::all_labels_type_
  pointer_query_columns< ::DuaBytes, id_pgsql, A >::
  all_labels (A::table_name, "\"all_labels\"", "(?)::INTEGER[]");

  template <>
  class access::object_traits_impl< ::DuaBytes, id_pgsql >:
    public access::object_traits< ::DuaBytes >
  {
    public:
    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    struct image_type
    {
      // id
      //
      long long id_value;
      bool id_null;

      // dua
      //
      long long dua_value;
      bool dua_null;

      // selected
      //
      composite_value_traits< ::Range, id_pgsql >::image_type selected_value;

      // all_labels
      //
      details::buffer all_labels_value;
      std::size_t all_labels_size;
      bool all_labels_null;

      std::size_t version;
    };

    struct extra_statement_cache_type;

    struct dua_tag;

    using object_traits<object_type>::id;

    static id_type
    id (const id_image_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&,
          bool*);

    static void
    bind (pgsql::bind*,
          image_type&,
          pgsql::statement_kind);

    static void
    bind (pgsql::bind*, id_image_type&);

    static bool
    init (image_type&,
          const object_type&,
          pgsql::statement_kind);

    static void
    init (object_type&,
          const image_type&,
          database*);

    static void
    init (id_image_type&, const id_type&);

    typedef pgsql::object_statements<object_type> statements_type;

    typedef pgsql::query_base query_base_type;

    static const std::size_t column_count = 5UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const std::size_t separate_load_column_count = 0UL;
    static const std::size_t separate_update_column_count = 0UL;

    static const bool versioned = false;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static odb::details::shared_ptr<prepared_query_impl>
    prepare_query (connection&, const char*, const query_base_type&);

    static odb::details::shared_ptr<result_impl>
    execute_query (prepared_query_impl&);

    static const char persist_statement_name[];
    static const char find_statement_name[];
    static const char update_statement_name[];
    static const char erase_statement_name[];
    static const char query_statement_name[];
    static const char erase_query_statement_name[];

    static const unsigned int persist_statement_types[];
    static const unsigned int find_statement_types[];
    static const unsigned int update_statement_types[];

    public:
    static bool
    find_ (statements_type&,
           const id_type*);

    static void
    load_ (statements_type&,
           object_type&,
           bool reload);
  };

  template <>
  class access::object_traits_impl< ::DuaBytes, id_common >:
    public access::object_traits_impl< ::DuaBytes, id_pgsql >
  {
  };

  // AttackPoint
  //
  template <typename A>
  struct query_columns< ::AttackPoint, id_pgsql, A >
  {
    // id
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint64_t,
        pgsql::id_bigint >::query_type,
      pgsql::id_bigint >
    id_type_;

    static const id_type_ id;

    // loc
    //
    struct loc_class_
    {
      loc_class_ ()
      {
      }

      // filename
      //
      typedef
      pgsql::query_column<
        pgsql::value_traits<
          ::std::string,
          pgsql::id_string >::query_type,
        pgsql::id_string >
      filename_type_;

      static const filename_type_ filename;

      // begin
      //
      struct begin_class_1_
      {
        begin_class_1_ ()
        {
        }

        // line
        //
        typedef
        pgsql::query_column<
          pgsql::value_traits<
            ::uint32_t,
            pgsql::id_integer >::query_type,
          pgsql::id_integer >
        line_type_;

        static const line_type_ line;

        // column
        //
        typedef
        pgsql::query_column<
          pgsql::value_traits<
            ::uint32_t,
            pgsql::id_integer >::query_type,
          pgsql::id_integer >
        column_type_;

        static const column_type_ column;
      };

      static const begin_class_1_ begin;

      // end
      //
      struct end_class_1_
      {
        end_class_1_ ()
        {
        }

        // line
        //
        typedef
        pgsql::query_column<
          pgsql::value_traits<
            ::uint32_t,
            pgsql::id_integer >::query_type,
          pgsql::id_integer >
        line_type_;

        static const line_type_ line;

        // column
        //
        typedef
        pgsql::query_column<
          pgsql::value_traits<
            ::uint32_t,
            pgsql::id_integer >::query_type,
          pgsql::id_integer >
        column_type_;

        static const column_type_ column;
      };

      static const end_class_1_ end;
    };

    static const loc_class_ loc;

    // type
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::AttackPoint::Type,
        pgsql::id_integer >::query_type,
      pgsql::id_integer >
    type_type_;

    static const type_type_ type;
  };

  template <typename A>
  const typename query_columns< ::AttackPoint, id_pgsql, A >::id_type_
  query_columns< ::AttackPoint, id_pgsql, A >::
  id (A::table_name, "\"id\"", 0);

  template <typename A>
  const typename query_columns< ::AttackPoint, id_pgsql, A >::loc_class_::filename_type_
  query_columns< ::AttackPoint, id_pgsql, A >::loc_class_::
  filename (A::table_name, "\"loc_filename\"", 0);

  template <typename A>
  const typename query_columns< ::AttackPoint, id_pgsql, A >::loc_class_::begin_class_1_::line_type_
  query_columns< ::AttackPoint, id_pgsql, A >::loc_class_::begin_class_1_::
  line (A::table_name, "\"loc_begin_line\"", 0);

  template <typename A>
  const typename query_columns< ::AttackPoint, id_pgsql, A >::loc_class_::begin_class_1_::column_type_
  query_columns< ::AttackPoint, id_pgsql, A >::loc_class_::begin_class_1_::
  column (A::table_name, "\"loc_begin_column\"", 0);

  template <typename A>
  const typename query_columns< ::AttackPoint, id_pgsql, A >::loc_class_::begin_class_1_
  query_columns< ::AttackPoint, id_pgsql, A >::loc_class_::begin;

  template <typename A>
  const typename query_columns< ::AttackPoint, id_pgsql, A >::loc_class_::end_class_1_::line_type_
  query_columns< ::AttackPoint, id_pgsql, A >::loc_class_::end_class_1_::
  line (A::table_name, "\"loc_end_line\"", 0);

  template <typename A>
  const typename query_columns< ::AttackPoint, id_pgsql, A >::loc_class_::end_class_1_::column_type_
  query_columns< ::AttackPoint, id_pgsql, A >::loc_class_::end_class_1_::
  column (A::table_name, "\"loc_end_column\"", 0);

  template <typename A>
  const typename query_columns< ::AttackPoint, id_pgsql, A >::loc_class_::end_class_1_
  query_columns< ::AttackPoint, id_pgsql, A >::loc_class_::end;

  template <typename A>
  const typename query_columns< ::AttackPoint, id_pgsql, A >::loc_class_
  query_columns< ::AttackPoint, id_pgsql, A >::loc;

  template <typename A>
  const typename query_columns< ::AttackPoint, id_pgsql, A >::type_type_
  query_columns< ::AttackPoint, id_pgsql, A >::
  type (A::table_name, "\"type\"", 0);

  template <typename A>
  struct pointer_query_columns< ::AttackPoint, id_pgsql, A >:
    query_columns< ::AttackPoint, id_pgsql, A >
  {
  };

  template <>
  class access::object_traits_impl< ::AttackPoint, id_pgsql >:
    public access::object_traits< ::AttackPoint >
  {
    public:
    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    struct image_type
    {
      // id
      //
      long long id_value;
      bool id_null;

      // loc
      //
      composite_value_traits< ::LavaASTLoc, id_pgsql >::image_type loc_value;

      // type
      //
      int type_value;
      bool type_null;

      std::size_t version;
    };

    struct extra_statement_cache_type;

    using object_traits<object_type>::id;

    static id_type
    id (const id_image_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&,
          bool*);

    static void
    bind (pgsql::bind*,
          image_type&,
          pgsql::statement_kind);

    static void
    bind (pgsql::bind*, id_image_type&);

    static bool
    init (image_type&,
          const object_type&,
          pgsql::statement_kind);

    static void
    init (object_type&,
          const image_type&,
          database*);

    static void
    init (id_image_type&, const id_type&);

    typedef pgsql::object_statements<object_type> statements_type;

    typedef pgsql::query_base query_base_type;

    static const std::size_t column_count = 7UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const std::size_t separate_load_column_count = 0UL;
    static const std::size_t separate_update_column_count = 0UL;

    static const bool versioned = false;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static odb::details::shared_ptr<prepared_query_impl>
    prepare_query (connection&, const char*, const query_base_type&);

    static odb::details::shared_ptr<result_impl>
    execute_query (prepared_query_impl&);

    static const char persist_statement_name[];
    static const char find_statement_name[];
    static const char update_statement_name[];
    static const char erase_statement_name[];
    static const char query_statement_name[];
    static const char erase_query_statement_name[];

    static const unsigned int persist_statement_types[];
    static const unsigned int find_statement_types[];
    static const unsigned int update_statement_types[];

    public:
    static bool
    find_ (statements_type&,
           const id_type*);

    static void
    load_ (statements_type&,
           object_type&,
           bool reload);
  };

  template <>
  class access::object_traits_impl< ::AttackPoint, id_common >:
    public access::object_traits_impl< ::AttackPoint, id_pgsql >
  {
  };

  // Bug
  //
  template <typename A>
  struct pointer_query_columns< ::Bug, id_pgsql, A >
  {
    // id
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint64_t,
        pgsql::id_bigint >::query_type,
      pgsql::id_bigint >
    id_type_;

    static const id_type_ id;

    // type
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::Bug::Type,
        pgsql::id_integer >::query_type,
      pgsql::id_integer >
    type_type_;

    static const type_type_ type;

    // trigger
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint64_t,
        pgsql::id_bigint >::query_type,
      pgsql::id_bigint >
    trigger_type_;

    static const trigger_type_ trigger;

    // trigger_lval
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint64_t,
        pgsql::id_bigint >::query_type,
      pgsql::id_bigint >
    trigger_lval_type_;

    static const trigger_lval_type_ trigger_lval;

    // atp
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint64_t,
        pgsql::id_bigint >::query_type,
      pgsql::id_bigint >
    atp_type_;

    static const atp_type_ atp;

    // max_liveness
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint64_t,
        pgsql::id_bigint >::query_type,
      pgsql::id_bigint >
    max_liveness_type_;

    static const max_liveness_type_ max_liveness;

    // extra_duas
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::std::vector< long unsigned int >,
        pgsql::id_string >::query_type,
      pgsql::id_string >
    extra_duas_type_;

    static const extra_duas_type_ extra_duas;

    // magic
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint32_t,
        pgsql::id_integer >::query_type,
      pgsql::id_integer >
    magic_type_;

    static const magic_type_ magic;
  };

  template <typename A>
  const typename pointer_query_columns< ::Bug, id_pgsql, A >::id_type_
  pointer_query_columns< ::Bug, id_pgsql, A >::
  id (A::table_name, "\"id\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::Bug, id_pgsql, A >::type_type_
  pointer_query_columns< ::Bug, id_pgsql, A >::
  type (A::table_name, "\"type\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::Bug, id_pgsql, A >::trigger_type_
  pointer_query_columns< ::Bug, id_pgsql, A >::
  trigger (A::table_name, "\"trigger\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::Bug, id_pgsql, A >::trigger_lval_type_
  pointer_query_columns< ::Bug, id_pgsql, A >::
  trigger_lval (A::table_name, "\"trigger_lval\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::Bug, id_pgsql, A >::atp_type_
  pointer_query_columns< ::Bug, id_pgsql, A >::
  atp (A::table_name, "\"atp\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::Bug, id_pgsql, A >::max_liveness_type_
  pointer_query_columns< ::Bug, id_pgsql, A >::
  max_liveness (A::table_name, "\"max_liveness\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::Bug, id_pgsql, A >::extra_duas_type_
  pointer_query_columns< ::Bug, id_pgsql, A >::
  extra_duas (A::table_name, "\"extra_duas\"", "(?)::BIGINT[]");

  template <typename A>
  const typename pointer_query_columns< ::Bug, id_pgsql, A >::magic_type_
  pointer_query_columns< ::Bug, id_pgsql, A >::
  magic (A::table_name, "\"magic\"", 0);

  template <>
  class access::object_traits_impl< ::Bug, id_pgsql >:
    public access::object_traits< ::Bug >
  {
    public:
    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    struct image_type
    {
      // id
      //
      long long id_value;
      bool id_null;

      // type
      //
      int type_value;
      bool type_null;

      // trigger
      //
      long long trigger_value;
      bool trigger_null;

      // trigger_lval
      //
      long long trigger_lval_value;
      bool trigger_lval_null;

      // atp
      //
      long long atp_value;
      bool atp_null;

      // max_liveness
      //
      long long max_liveness_value;
      bool max_liveness_null;

      // extra_duas
      //
      details::buffer extra_duas_value;
      std::size_t extra_duas_size;
      bool extra_duas_null;

      // magic
      //
      int magic_value;
      bool magic_null;

      std::size_t version;
    };

    struct extra_statement_cache_type;

    struct trigger_tag;
    struct trigger_lval_tag;
    struct atp_tag;

    using object_traits<object_type>::id;

    static id_type
    id (const id_image_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&,
          bool*);

    static void
    bind (pgsql::bind*,
          image_type&,
          pgsql::statement_kind);

    static void
    bind (pgsql::bind*, id_image_type&);

    static bool
    init (image_type&,
          const object_type&,
          pgsql::statement_kind);

    static void
    init (object_type&,
          const image_type&,
          database*);

    static void
    init (id_image_type&, const id_type&);

    typedef pgsql::object_statements<object_type> statements_type;

    typedef pgsql::query_base query_base_type;

    static const std::size_t column_count = 8UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const std::size_t separate_load_column_count = 0UL;
    static const std::size_t separate_update_column_count = 0UL;

    static const bool versioned = false;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static odb::details::shared_ptr<prepared_query_impl>
    prepare_query (connection&, const char*, const query_base_type&);

    static odb::details::shared_ptr<result_impl>
    execute_query (prepared_query_impl&);

    static const char persist_statement_name[];
    static const char find_statement_name[];
    static const char update_statement_name[];
    static const char erase_statement_name[];
    static const char query_statement_name[];
    static const char erase_query_statement_name[];

    static const unsigned int persist_statement_types[];
    static const unsigned int find_statement_types[];
    static const unsigned int update_statement_types[];

    public:
    static bool
    find_ (statements_type&,
           const id_type*);

    static void
    load_ (statements_type&,
           object_type&,
           bool reload);
  };

  template <>
  class access::object_traits_impl< ::Bug, id_common >:
    public access::object_traits_impl< ::Bug, id_pgsql >
  {
  };

  // BugLval
  //
  template <>
  class access::view_traits_impl< ::BugLval, id_pgsql >:
    public access::view_traits< ::BugLval >
  {
    public:
    struct image_type
    {
      // trigger_lval
      //
      long long trigger_lval_value;
      bool trigger_lval_null;

      std::size_t version;
    };

    typedef pgsql::view_statements<view_type> statements_type;

    typedef pgsql::query_base query_base_type;
    struct query_columns;

    static const bool versioned = false;

    static bool
    grow (image_type&,
          bool*);

    static void
    bind (pgsql::bind*,
          image_type&);

    static void
    init (view_type&,
          const image_type&,
          database*);

    static const std::size_t column_count = 1UL;

    static query_base_type
    query_statement (const query_base_type&);

    static result<view_type>
    query (database&, const query_base_type&);

    static odb::details::shared_ptr<prepared_query_impl>
    prepare_query (connection&, const char*, const query_base_type&);

    static odb::details::shared_ptr<result_impl>
    execute_query (prepared_query_impl&);

    static const char query_statement_name[];
  };

  template <>
  class access::view_traits_impl< ::BugLval, id_common >:
    public access::view_traits_impl< ::BugLval, id_pgsql >
  {
  };

  // Build
  //
  template <typename A>
  struct query_columns< ::Build, id_pgsql, A >
  {
    // id
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint64_t,
        pgsql::id_bigint >::query_type,
      pgsql::id_bigint >
    id_type_;

    static const id_type_ id;

    // output
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::std::string,
        pgsql::id_string >::query_type,
      pgsql::id_string >
    output_type_;

    static const output_type_ output;

    // compile
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        bool,
        pgsql::id_boolean >::query_type,
      pgsql::id_boolean >
    compile_type_;

    static const compile_type_ compile;
  };

  template <typename A>
  const typename query_columns< ::Build, id_pgsql, A >::id_type_
  query_columns< ::Build, id_pgsql, A >::
  id (A::table_name, "\"id\"", 0);

  template <typename A>
  const typename query_columns< ::Build, id_pgsql, A >::output_type_
  query_columns< ::Build, id_pgsql, A >::
  output (A::table_name, "\"output\"", 0);

  template <typename A>
  const typename query_columns< ::Build, id_pgsql, A >::compile_type_
  query_columns< ::Build, id_pgsql, A >::
  compile (A::table_name, "\"compile\"", 0);

  template <typename A>
  struct pointer_query_columns< ::Build, id_pgsql, A >:
    query_columns< ::Build, id_pgsql, A >
  {
  };

  template <>
  class access::object_traits_impl< ::Build, id_pgsql >:
    public access::object_traits< ::Build >
  {
    public:
    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    struct image_type
    {
      // id
      //
      long long id_value;
      bool id_null;

      // output
      //
      details::buffer output_value;
      std::size_t output_size;
      bool output_null;

      // compile
      //
      bool compile_value;
      bool compile_null;

      std::size_t version;
    };

    struct extra_statement_cache_type;

    // bugs
    //
    struct bugs_traits
    {
      static const char select_name[];
      static const char insert_name[];
      static const char delete_name[];

      static const unsigned int insert_types[];

      static const std::size_t id_column_count = 1UL;
      static const std::size_t data_column_count = 3UL;

      static const bool versioned = false;

      static const char insert_statement[];
      static const char select_statement[];
      static const char delete_statement[];

      typedef ::std::vector< const ::Bug* > container_type;
      typedef
      odb::access::container_traits<container_type>
      container_traits_type;
      typedef container_traits_type::index_type index_type;
      typedef container_traits_type::value_type value_type;

      typedef ordered_functions<index_type, value_type> functions_type;
      typedef pgsql::container_statements< bugs_traits > statements_type;

      struct data_image_type
      {
        // index
        //
        long long index_value;
        bool index_null;

        // value
        //
        long long value_value;
        bool value_null;

        std::size_t version;
      };

      static void
      bind (pgsql::bind*,
            const pgsql::bind* id,
            std::size_t id_size,
            data_image_type&);

      static void
      grow (data_image_type&,
            bool*);

      static void
      init (data_image_type&,
            index_type*,
            const value_type&);

      static void
      init (index_type&,
            value_type&,
            const data_image_type&,
            database*);

      static void
      insert (index_type, const value_type&, void*);

      static bool
      select (index_type&, value_type&, void*);

      static void
      delete_ (void*);

      static void
      persist (const container_type&,
               statements_type&);

      static void
      load (container_type&,
            statements_type&);

      static void
      update (const container_type&,
              statements_type&);

      static void
      erase (statements_type&);
    };

    using object_traits<object_type>::id;

    static id_type
    id (const id_image_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&,
          bool*);

    static void
    bind (pgsql::bind*,
          image_type&,
          pgsql::statement_kind);

    static void
    bind (pgsql::bind*, id_image_type&);

    static bool
    init (image_type&,
          const object_type&,
          pgsql::statement_kind);

    static void
    init (object_type&,
          const image_type&,
          database*);

    static void
    init (id_image_type&, const id_type&);

    typedef pgsql::object_statements<object_type> statements_type;

    typedef pgsql::query_base query_base_type;

    static const std::size_t column_count = 3UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const std::size_t separate_load_column_count = 0UL;
    static const std::size_t separate_update_column_count = 0UL;

    static const bool versioned = false;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static odb::details::shared_ptr<prepared_query_impl>
    prepare_query (connection&, const char*, const query_base_type&);

    static odb::details::shared_ptr<result_impl>
    execute_query (prepared_query_impl&);

    static const char persist_statement_name[];
    static const char find_statement_name[];
    static const char update_statement_name[];
    static const char erase_statement_name[];
    static const char query_statement_name[];
    static const char erase_query_statement_name[];

    static const unsigned int persist_statement_types[];
    static const unsigned int find_statement_types[];
    static const unsigned int update_statement_types[];

    public:
    static bool
    find_ (statements_type&,
           const id_type*);

    static void
    load_ (statements_type&,
           object_type&,
           bool reload);
  };

  template <>
  class access::object_traits_impl< ::Build, id_common >:
    public access::object_traits_impl< ::Build, id_pgsql >
  {
  };

  // Run
  //
  template <typename A>
  struct pointer_query_columns< ::Run, id_pgsql, A >
  {
    // id
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint64_t,
        pgsql::id_bigint >::query_type,
      pgsql::id_bigint >
    id_type_;

    static const id_type_ id;

    // build
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint64_t,
        pgsql::id_bigint >::query_type,
      pgsql::id_bigint >
    build_type_;

    static const build_type_ build;

    // fuzzed
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint64_t,
        pgsql::id_bigint >::query_type,
      pgsql::id_bigint >
    fuzzed_type_;

    static const fuzzed_type_ fuzzed;

    // exitcode
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        int,
        pgsql::id_integer >::query_type,
      pgsql::id_integer >
    exitcode_type_;

    static const exitcode_type_ exitcode;

    // output
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::std::string,
        pgsql::id_string >::query_type,
      pgsql::id_string >
    output_type_;

    static const output_type_ output;

    // success
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        bool,
        pgsql::id_boolean >::query_type,
      pgsql::id_boolean >
    success_type_;

    static const success_type_ success;

    // validated
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        bool,
        pgsql::id_boolean >::query_type,
      pgsql::id_boolean >
    validated_type_;

    static const validated_type_ validated;
  };

  template <typename A>
  const typename pointer_query_columns< ::Run, id_pgsql, A >::id_type_
  pointer_query_columns< ::Run, id_pgsql, A >::
  id (A::table_name, "\"id\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::Run, id_pgsql, A >::build_type_
  pointer_query_columns< ::Run, id_pgsql, A >::
  build (A::table_name, "\"build\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::Run, id_pgsql, A >::fuzzed_type_
  pointer_query_columns< ::Run, id_pgsql, A >::
  fuzzed (A::table_name, "\"fuzzed\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::Run, id_pgsql, A >::exitcode_type_
  pointer_query_columns< ::Run, id_pgsql, A >::
  exitcode (A::table_name, "\"exitcode\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::Run, id_pgsql, A >::output_type_
  pointer_query_columns< ::Run, id_pgsql, A >::
  output (A::table_name, "\"output\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::Run, id_pgsql, A >::success_type_
  pointer_query_columns< ::Run, id_pgsql, A >::
  success (A::table_name, "\"success\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::Run, id_pgsql, A >::validated_type_
  pointer_query_columns< ::Run, id_pgsql, A >::
  validated (A::table_name, "\"validated\"", 0);

  template <>
  class access::object_traits_impl< ::Run, id_pgsql >:
    public access::object_traits< ::Run >
  {
    public:
    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    struct image_type
    {
      // id
      //
      long long id_value;
      bool id_null;

      // build
      //
      long long build_value;
      bool build_null;

      // fuzzed
      //
      long long fuzzed_value;
      bool fuzzed_null;

      // exitcode
      //
      int exitcode_value;
      bool exitcode_null;

      // output
      //
      details::buffer output_value;
      std::size_t output_size;
      bool output_null;

      // success
      //
      bool success_value;
      bool success_null;

      // validated
      //
      bool validated_value;
      bool validated_null;

      std::size_t version;
    };

    struct extra_statement_cache_type;

    struct build_tag;
    struct fuzzed_tag;

    using object_traits<object_type>::id;

    static id_type
    id (const id_image_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&,
          bool*);

    static void
    bind (pgsql::bind*,
          image_type&,
          pgsql::statement_kind);

    static void
    bind (pgsql::bind*, id_image_type&);

    static bool
    init (image_type&,
          const object_type&,
          pgsql::statement_kind);

    static void
    init (object_type&,
          const image_type&,
          database*);

    static void
    init (id_image_type&, const id_type&);

    typedef pgsql::object_statements<object_type> statements_type;

    typedef pgsql::query_base query_base_type;

    static const std::size_t column_count = 7UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const std::size_t separate_load_column_count = 0UL;
    static const std::size_t separate_update_column_count = 0UL;

    static const bool versioned = false;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static odb::details::shared_ptr<prepared_query_impl>
    prepare_query (connection&, const char*, const query_base_type&);

    static odb::details::shared_ptr<result_impl>
    execute_query (prepared_query_impl&);

    static const char persist_statement_name[];
    static const char find_statement_name[];
    static const char update_statement_name[];
    static const char erase_statement_name[];
    static const char query_statement_name[];
    static const char erase_query_statement_name[];

    static const unsigned int persist_statement_types[];
    static const unsigned int find_statement_types[];
    static const unsigned int update_statement_types[];

    public:
    static bool
    find_ (statements_type&,
           const id_type*);

    static void
    load_ (statements_type&,
           object_type&,
           bool reload);
  };

  template <>
  class access::object_traits_impl< ::Run, id_common >:
    public access::object_traits_impl< ::Run, id_pgsql >
  {
  };

  // SourceFunction
  //
  template <typename A>
  struct query_columns< ::SourceFunction, id_pgsql, A >
  {
    // id
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint64_t,
        pgsql::id_bigint >::query_type,
      pgsql::id_bigint >
    id_type_;

    static const id_type_ id;

    // loc
    //
    struct loc_class_
    {
      loc_class_ ()
      {
      }

      // filename
      //
      typedef
      pgsql::query_column<
        pgsql::value_traits<
          ::std::string,
          pgsql::id_string >::query_type,
        pgsql::id_string >
      filename_type_;

      static const filename_type_ filename;

      // begin
      //
      struct begin_class_1_
      {
        begin_class_1_ ()
        {
        }

        // line
        //
        typedef
        pgsql::query_column<
          pgsql::value_traits<
            ::uint32_t,
            pgsql::id_integer >::query_type,
          pgsql::id_integer >
        line_type_;

        static const line_type_ line;

        // column
        //
        typedef
        pgsql::query_column<
          pgsql::value_traits<
            ::uint32_t,
            pgsql::id_integer >::query_type,
          pgsql::id_integer >
        column_type_;

        static const column_type_ column;
      };

      static const begin_class_1_ begin;

      // end
      //
      struct end_class_1_
      {
        end_class_1_ ()
        {
        }

        // line
        //
        typedef
        pgsql::query_column<
          pgsql::value_traits<
            ::uint32_t,
            pgsql::id_integer >::query_type,
          pgsql::id_integer >
        line_type_;

        static const line_type_ line;

        // column
        //
        typedef
        pgsql::query_column<
          pgsql::value_traits<
            ::uint32_t,
            pgsql::id_integer >::query_type,
          pgsql::id_integer >
        column_type_;

        static const column_type_ column;
      };

      static const end_class_1_ end;
    };

    static const loc_class_ loc;

    // name
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::std::string,
        pgsql::id_string >::query_type,
      pgsql::id_string >
    name_type_;

    static const name_type_ name;
  };

  template <typename A>
  const typename query_columns< ::SourceFunction, id_pgsql, A >::id_type_
  query_columns< ::SourceFunction, id_pgsql, A >::
  id (A::table_name, "\"id\"", 0);

  template <typename A>
  const typename query_columns< ::SourceFunction, id_pgsql, A >::loc_class_::filename_type_
  query_columns< ::SourceFunction, id_pgsql, A >::loc_class_::
  filename (A::table_name, "\"loc_filename\"", 0);

  template <typename A>
  const typename query_columns< ::SourceFunction, id_pgsql, A >::loc_class_::begin_class_1_::line_type_
  query_columns< ::SourceFunction, id_pgsql, A >::loc_class_::begin_class_1_::
  line (A::table_name, "\"loc_begin_line\"", 0);

  template <typename A>
  const typename query_columns< ::SourceFunction, id_pgsql, A >::loc_class_::begin_class_1_::column_type_
  query_columns< ::SourceFunction, id_pgsql, A >::loc_class_::begin_class_1_::
  column (A::table_name, "\"loc_begin_column\"", 0);

  template <typename A>
  const typename query_columns< ::SourceFunction, id_pgsql, A >::loc_class_::begin_class_1_
  query_columns< ::SourceFunction, id_pgsql, A >::loc_class_::begin;

  template <typename A>
  const typename query_columns< ::SourceFunction, id_pgsql, A >::loc_class_::end_class_1_::line_type_
  query_columns< ::SourceFunction, id_pgsql, A >::loc_class_::end_class_1_::
  line (A::table_name, "\"loc_end_line\"", 0);

  template <typename A>
  const typename query_columns< ::SourceFunction, id_pgsql, A >::loc_class_::end_class_1_::column_type_
  query_columns< ::SourceFunction, id_pgsql, A >::loc_class_::end_class_1_::
  column (A::table_name, "\"loc_end_column\"", 0);

  template <typename A>
  const typename query_columns< ::SourceFunction, id_pgsql, A >::loc_class_::end_class_1_
  query_columns< ::SourceFunction, id_pgsql, A >::loc_class_::end;

  template <typename A>
  const typename query_columns< ::SourceFunction, id_pgsql, A >::loc_class_
  query_columns< ::SourceFunction, id_pgsql, A >::loc;

  template <typename A>
  const typename query_columns< ::SourceFunction, id_pgsql, A >::name_type_
  query_columns< ::SourceFunction, id_pgsql, A >::
  name (A::table_name, "\"name\"", 0);

  template <typename A>
  struct pointer_query_columns< ::SourceFunction, id_pgsql, A >:
    query_columns< ::SourceFunction, id_pgsql, A >
  {
  };

  template <>
  class access::object_traits_impl< ::SourceFunction, id_pgsql >:
    public access::object_traits< ::SourceFunction >
  {
    public:
    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    struct image_type
    {
      // id
      //
      long long id_value;
      bool id_null;

      // loc
      //
      composite_value_traits< ::LavaASTLoc, id_pgsql >::image_type loc_value;

      // name
      //
      details::buffer name_value;
      std::size_t name_size;
      bool name_null;

      std::size_t version;
    };

    struct extra_statement_cache_type;

    using object_traits<object_type>::id;

    static id_type
    id (const id_image_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&,
          bool*);

    static void
    bind (pgsql::bind*,
          image_type&,
          pgsql::statement_kind);

    static void
    bind (pgsql::bind*, id_image_type&);

    static bool
    init (image_type&,
          const object_type&,
          pgsql::statement_kind);

    static void
    init (object_type&,
          const image_type&,
          database*);

    static void
    init (id_image_type&, const id_type&);

    typedef pgsql::object_statements<object_type> statements_type;

    typedef pgsql::query_base query_base_type;

    static const std::size_t column_count = 7UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const std::size_t separate_load_column_count = 0UL;
    static const std::size_t separate_update_column_count = 0UL;

    static const bool versioned = false;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static odb::details::shared_ptr<prepared_query_impl>
    prepare_query (connection&, const char*, const query_base_type&);

    static odb::details::shared_ptr<result_impl>
    execute_query (prepared_query_impl&);

    static const char persist_statement_name[];
    static const char find_statement_name[];
    static const char update_statement_name[];
    static const char erase_statement_name[];
    static const char query_statement_name[];
    static const char erase_query_statement_name[];

    static const unsigned int persist_statement_types[];
    static const unsigned int find_statement_types[];
    static const unsigned int update_statement_types[];

    public:
    static bool
    find_ (statements_type&,
           const id_type*);

    static void
    load_ (statements_type&,
           object_type&,
           bool reload);
  };

  template <>
  class access::object_traits_impl< ::SourceFunction, id_common >:
    public access::object_traits_impl< ::SourceFunction, id_pgsql >
  {
  };

  // Call
  //
  template <typename A>
  struct pointer_query_columns< ::Call, id_pgsql, A >
  {
    // id
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint64_t,
        pgsql::id_bigint >::query_type,
      pgsql::id_bigint >
    id_type_;

    static const id_type_ id;

    // call_instr
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint64_t,
        pgsql::id_bigint >::query_type,
      pgsql::id_bigint >
    call_instr_type_;

    static const call_instr_type_ call_instr;

    // ret_instr
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint64_t,
        pgsql::id_bigint >::query_type,
      pgsql::id_bigint >
    ret_instr_type_;

    static const ret_instr_type_ ret_instr;

    // called_function
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint64_t,
        pgsql::id_bigint >::query_type,
      pgsql::id_bigint >
    called_function_type_;

    static const called_function_type_ called_function;

    // callsite_file
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::std::string,
        pgsql::id_string >::query_type,
      pgsql::id_string >
    callsite_file_type_;

    static const callsite_file_type_ callsite_file;

    // callsite_line
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint32_t,
        pgsql::id_integer >::query_type,
      pgsql::id_integer >
    callsite_line_type_;

    static const callsite_line_type_ callsite_line;
  };

  template <typename A>
  const typename pointer_query_columns< ::Call, id_pgsql, A >::id_type_
  pointer_query_columns< ::Call, id_pgsql, A >::
  id (A::table_name, "\"id\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::Call, id_pgsql, A >::call_instr_type_
  pointer_query_columns< ::Call, id_pgsql, A >::
  call_instr (A::table_name, "\"call_instr\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::Call, id_pgsql, A >::ret_instr_type_
  pointer_query_columns< ::Call, id_pgsql, A >::
  ret_instr (A::table_name, "\"ret_instr\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::Call, id_pgsql, A >::called_function_type_
  pointer_query_columns< ::Call, id_pgsql, A >::
  called_function (A::table_name, "\"called_function\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::Call, id_pgsql, A >::callsite_file_type_
  pointer_query_columns< ::Call, id_pgsql, A >::
  callsite_file (A::table_name, "\"callsite_file\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::Call, id_pgsql, A >::callsite_line_type_
  pointer_query_columns< ::Call, id_pgsql, A >::
  callsite_line (A::table_name, "\"callsite_line\"", 0);

  template <>
  class access::object_traits_impl< ::Call, id_pgsql >:
    public access::object_traits< ::Call >
  {
    public:
    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    struct image_type
    {
      // id
      //
      long long id_value;
      bool id_null;

      // call_instr
      //
      long long call_instr_value;
      bool call_instr_null;

      // ret_instr
      //
      long long ret_instr_value;
      bool ret_instr_null;

      // called_function
      //
      long long called_function_value;
      bool called_function_null;

      // callsite_file
      //
      details::buffer callsite_file_value;
      std::size_t callsite_file_size;
      bool callsite_file_null;

      // callsite_line
      //
      int callsite_line_value;
      bool callsite_line_null;

      std::size_t version;
    };

    struct extra_statement_cache_type;

    struct called_function_tag;

    using object_traits<object_type>::id;

    static id_type
    id (const id_image_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&,
          bool*);

    static void
    bind (pgsql::bind*,
          image_type&,
          pgsql::statement_kind);

    static void
    bind (pgsql::bind*, id_image_type&);

    static bool
    init (image_type&,
          const object_type&,
          pgsql::statement_kind);

    static void
    init (object_type&,
          const image_type&,
          database*);

    static void
    init (id_image_type&, const id_type&);

    typedef pgsql::object_statements<object_type> statements_type;

    typedef pgsql::query_base query_base_type;

    static const std::size_t column_count = 6UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const std::size_t separate_load_column_count = 0UL;
    static const std::size_t separate_update_column_count = 0UL;

    static const bool versioned = false;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static odb::details::shared_ptr<prepared_query_impl>
    prepare_query (connection&, const char*, const query_base_type&);

    static odb::details::shared_ptr<result_impl>
    execute_query (prepared_query_impl&);

    static const char persist_statement_name[];
    static const char find_statement_name[];
    static const char update_statement_name[];
    static const char erase_statement_name[];
    static const char query_statement_name[];
    static const char erase_query_statement_name[];

    static const unsigned int persist_statement_types[];
    static const unsigned int find_statement_types[];
    static const unsigned int update_statement_types[];

    public:
    static bool
    find_ (statements_type&,
           const id_type*);

    static void
    load_ (statements_type&,
           object_type&,
           bool reload);
  };

  template <>
  class access::object_traits_impl< ::Call, id_common >:
    public access::object_traits_impl< ::Call, id_pgsql >
  {
  };

  // SourceLval
  //
  // LabelSet
  //
  // Dua
  //
  template <>
  struct alias_traits<
    ::SourceLval,
    id_pgsql,
    access::object_traits_impl< ::Dua, id_pgsql >::lval_tag>
  {
    static const char table_name[];
  };

  template <>
  struct query_columns_base< ::Dua, id_pgsql >
  {
    // lval
    //
    typedef
    odb::alias_traits<
      ::SourceLval,
      id_pgsql,
      access::object_traits_impl< ::Dua, id_pgsql >::lval_tag>
    lval_alias_;
  };

  template <typename A>
  struct query_columns< ::Dua, id_pgsql, A >:
    query_columns_base< ::Dua, id_pgsql >
  {
    // id
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint64_t,
        pgsql::id_bigint >::query_type,
      pgsql::id_bigint >
    id_type_;

    static const id_type_ id;

    // lval
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint64_t,
        pgsql::id_bigint >::query_type,
      pgsql::id_bigint >
    lval_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::SourceLval,
        id_pgsql,
        lval_alias_ > >
    lval_pointer_type_;

    struct lval_type_: lval_pointer_type_, lval_column_type_
    {
      lval_type_ (const char* t, const char* c, const char* conv)
        : lval_column_type_ (t, c, conv)
      {
      }
    };

    static const lval_type_ lval;

    // byte_tcn
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::std::vector< unsigned int >,
        pgsql::id_string >::query_type,
      pgsql::id_string >
    byte_tcn_type_;

    static const byte_tcn_type_ byte_tcn;

    // all_labels
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::std::vector< unsigned int >,
        pgsql::id_string >::query_type,
      pgsql::id_string >
    all_labels_type_;

    static const all_labels_type_ all_labels;

    // inputfile
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::std::string,
        pgsql::id_string >::query_type,
      pgsql::id_string >
    inputfile_type_;

    static const inputfile_type_ inputfile;

    // max_tcn
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint32_t,
        pgsql::id_integer >::query_type,
      pgsql::id_integer >
    max_tcn_type_;

    static const max_tcn_type_ max_tcn;

    // max_cardinality
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint32_t,
        pgsql::id_integer >::query_type,
      pgsql::id_integer >
    max_cardinality_type_;

    static const max_cardinality_type_ max_cardinality;

    // instr
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint64_t,
        pgsql::id_bigint >::query_type,
      pgsql::id_bigint >
    instr_type_;

    static const instr_type_ instr;

    // fake_dua
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        bool,
        pgsql::id_boolean >::query_type,
      pgsql::id_boolean >
    fake_dua_type_;

    static const fake_dua_type_ fake_dua;
  };

  template <typename A>
  const typename query_columns< ::Dua, id_pgsql, A >::id_type_
  query_columns< ::Dua, id_pgsql, A >::
  id (A::table_name, "\"id\"", 0);

  template <typename A>
  const typename query_columns< ::Dua, id_pgsql, A >::lval_type_
  query_columns< ::Dua, id_pgsql, A >::
  lval (A::table_name, "\"lval\"", 0);

  template <typename A>
  const typename query_columns< ::Dua, id_pgsql, A >::byte_tcn_type_
  query_columns< ::Dua, id_pgsql, A >::
  byte_tcn (A::table_name, "\"byte_tcn\"", "(?)::INTEGER[]");

  template <typename A>
  const typename query_columns< ::Dua, id_pgsql, A >::all_labels_type_
  query_columns< ::Dua, id_pgsql, A >::
  all_labels (A::table_name, "\"all_labels\"", "(?)::INTEGER[]");

  template <typename A>
  const typename query_columns< ::Dua, id_pgsql, A >::inputfile_type_
  query_columns< ::Dua, id_pgsql, A >::
  inputfile (A::table_name, "\"inputfile\"", 0);

  template <typename A>
  const typename query_columns< ::Dua, id_pgsql, A >::max_tcn_type_
  query_columns< ::Dua, id_pgsql, A >::
  max_tcn (A::table_name, "\"max_tcn\"", 0);

  template <typename A>
  const typename query_columns< ::Dua, id_pgsql, A >::max_cardinality_type_
  query_columns< ::Dua, id_pgsql, A >::
  max_cardinality (A::table_name, "\"max_cardinality\"", 0);

  template <typename A>
  const typename query_columns< ::Dua, id_pgsql, A >::instr_type_
  query_columns< ::Dua, id_pgsql, A >::
  instr (A::table_name, "\"instr\"", 0);

  template <typename A>
  const typename query_columns< ::Dua, id_pgsql, A >::fake_dua_type_
  query_columns< ::Dua, id_pgsql, A >::
  fake_dua (A::table_name, "\"fake_dua\"", 0);

  // DuaBytes
  //
  template <>
  struct alias_traits<
    ::Dua,
    id_pgsql,
    access::object_traits_impl< ::DuaBytes, id_pgsql >::dua_tag>
  {
    static const char table_name[];
  };

  template <>
  struct query_columns_base< ::DuaBytes, id_pgsql >
  {
    // dua
    //
    typedef
    odb::alias_traits<
      ::Dua,
      id_pgsql,
      access::object_traits_impl< ::DuaBytes, id_pgsql >::dua_tag>
    dua_alias_;
  };

  template <typename A>
  struct query_columns< ::DuaBytes, id_pgsql, A >:
    query_columns_base< ::DuaBytes, id_pgsql >
  {
    // id
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint64_t,
        pgsql::id_bigint >::query_type,
      pgsql::id_bigint >
    id_type_;

    static const id_type_ id;

    // dua
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint64_t,
        pgsql::id_bigint >::query_type,
      pgsql::id_bigint >
    dua_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::Dua,
        id_pgsql,
        dua_alias_ > >
    dua_pointer_type_;

    struct dua_type_: dua_pointer_type_, dua_column_type_
    {
      dua_type_ (const char* t, const char* c, const char* conv)
        : dua_column_type_ (t, c, conv)
      {
      }
    };

    static const dua_type_ dua;

    // selected
    //
    struct selected_class_
    {
      selected_class_ ()
      {
      }

      // low
      //
      typedef
      pgsql::query_column<
        pgsql::value_traits<
          ::uint32_t,
          pgsql::id_integer >::query_type,
        pgsql::id_integer >
      low_type_;

      static const low_type_ low;

      // high
      //
      typedef
      pgsql::query_column<
        pgsql::value_traits<
          ::uint32_t,
          pgsql::id_integer >::query_type,
        pgsql::id_integer >
      high_type_;

      static const high_type_ high;
    };

    static const selected_class_ selected;

    // all_labels
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::std::vector< unsigned int >,
        pgsql::id_string >::query_type,
      pgsql::id_string >
    all_labels_type_;

    static const all_labels_type_ all_labels;
  };

  template <typename A>
  const typename query_columns< ::DuaBytes, id_pgsql, A >::id_type_
  query_columns< ::DuaBytes, id_pgsql, A >::
  id (A::table_name, "\"id\"", 0);

  template <typename A>
  const typename query_columns< ::DuaBytes, id_pgsql, A >::dua_type_
  query_columns< ::DuaBytes, id_pgsql, A >::
  dua (A::table_name, "\"dua\"", 0);

  template <typename A>
  const typename query_columns< ::DuaBytes, id_pgsql, A >::selected_class_::low_type_
  query_columns< ::DuaBytes, id_pgsql, A >::selected_class_::
  low (A::table_name, "\"selected_low\"", 0);

  template <typename A>
  const typename query_columns< ::DuaBytes, id_pgsql, A >::selected_class_::high_type_
  query_columns< ::DuaBytes, id_pgsql, A >::selected_class_::
  high (A::table_name, "\"selected_high\"", 0);

  template <typename A>
  const typename query_columns< ::DuaBytes, id_pgsql, A >::selected_class_
  query_columns< ::DuaBytes, id_pgsql, A >::selected;

  template <typename A>
  const typename query_columns< ::DuaBytes, id_pgsql, A >::all_labels_type_
  query_columns< ::DuaBytes, id_pgsql, A >::
  all_labels (A::table_name, "\"all_labels\"", "(?)::INTEGER[]");

  // AttackPoint
  //
  // Bug
  //
  template <>
  struct alias_traits<
    ::DuaBytes,
    id_pgsql,
    access::object_traits_impl< ::Bug, id_pgsql >::trigger_tag>
  {
    static const char table_name[];
  };

  template <>
  struct alias_traits<
    ::SourceLval,
    id_pgsql,
    access::object_traits_impl< ::Bug, id_pgsql >::trigger_lval_tag>
  {
    static const char table_name[];
  };

  template <>
  struct alias_traits<
    ::AttackPoint,
    id_pgsql,
    access::object_traits_impl< ::Bug, id_pgsql >::atp_tag>
  {
    static const char table_name[];
  };

  template <>
  struct query_columns_base< ::Bug, id_pgsql >
  {
    // trigger
    //
    typedef
    odb::alias_traits<
      ::DuaBytes,
      id_pgsql,
      access::object_traits_impl< ::Bug, id_pgsql >::trigger_tag>
    trigger_alias_;

    // trigger_lval
    //
    typedef
    odb::alias_traits<
      ::SourceLval,
      id_pgsql,
      access::object_traits_impl< ::Bug, id_pgsql >::trigger_lval_tag>
    trigger_lval_alias_;

    // atp
    //
    typedef
    odb::alias_traits<
      ::AttackPoint,
      id_pgsql,
      access::object_traits_impl< ::Bug, id_pgsql >::atp_tag>
    atp_alias_;
  };

  template <typename A>
  struct query_columns< ::Bug, id_pgsql, A >:
    query_columns_base< ::Bug, id_pgsql >
  {
    // id
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint64_t,
        pgsql::id_bigint >::query_type,
      pgsql::id_bigint >
    id_type_;

    static const id_type_ id;

    // type
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::Bug::Type,
        pgsql::id_integer >::query_type,
      pgsql::id_integer >
    type_type_;

    static const type_type_ type;

    // trigger
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint64_t,
        pgsql::id_bigint >::query_type,
      pgsql::id_bigint >
    trigger_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::DuaBytes,
        id_pgsql,
        trigger_alias_ > >
    trigger_pointer_type_;

    struct trigger_type_: trigger_pointer_type_, trigger_column_type_
    {
      trigger_type_ (const char* t, const char* c, const char* conv)
        : trigger_column_type_ (t, c, conv)
      {
      }
    };

    static const trigger_type_ trigger;

    // trigger_lval
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint64_t,
        pgsql::id_bigint >::query_type,
      pgsql::id_bigint >
    trigger_lval_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::SourceLval,
        id_pgsql,
        trigger_lval_alias_ > >
    trigger_lval_pointer_type_;

    struct trigger_lval_type_: trigger_lval_pointer_type_, trigger_lval_column_type_
    {
      trigger_lval_type_ (const char* t, const char* c, const char* conv)
        : trigger_lval_column_type_ (t, c, conv)
      {
      }
    };

    static const trigger_lval_type_ trigger_lval;

    // atp
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint64_t,
        pgsql::id_bigint >::query_type,
      pgsql::id_bigint >
    atp_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::AttackPoint,
        id_pgsql,
        atp_alias_ > >
    atp_pointer_type_;

    struct atp_type_: atp_pointer_type_, atp_column_type_
    {
      atp_type_ (const char* t, const char* c, const char* conv)
        : atp_column_type_ (t, c, conv)
      {
      }
    };

    static const atp_type_ atp;

    // max_liveness
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint64_t,
        pgsql::id_bigint >::query_type,
      pgsql::id_bigint >
    max_liveness_type_;

    static const max_liveness_type_ max_liveness;

    // extra_duas
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::std::vector< long unsigned int >,
        pgsql::id_string >::query_type,
      pgsql::id_string >
    extra_duas_type_;

    static const extra_duas_type_ extra_duas;

    // magic
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint32_t,
        pgsql::id_integer >::query_type,
      pgsql::id_integer >
    magic_type_;

    static const magic_type_ magic;
  };

  template <typename A>
  const typename query_columns< ::Bug, id_pgsql, A >::id_type_
  query_columns< ::Bug, id_pgsql, A >::
  id (A::table_name, "\"id\"", 0);

  template <typename A>
  const typename query_columns< ::Bug, id_pgsql, A >::type_type_
  query_columns< ::Bug, id_pgsql, A >::
  type (A::table_name, "\"type\"", 0);

  template <typename A>
  const typename query_columns< ::Bug, id_pgsql, A >::trigger_type_
  query_columns< ::Bug, id_pgsql, A >::
  trigger (A::table_name, "\"trigger\"", 0);

  template <typename A>
  const typename query_columns< ::Bug, id_pgsql, A >::trigger_lval_type_
  query_columns< ::Bug, id_pgsql, A >::
  trigger_lval (A::table_name, "\"trigger_lval\"", 0);

  template <typename A>
  const typename query_columns< ::Bug, id_pgsql, A >::atp_type_
  query_columns< ::Bug, id_pgsql, A >::
  atp (A::table_name, "\"atp\"", 0);

  template <typename A>
  const typename query_columns< ::Bug, id_pgsql, A >::max_liveness_type_
  query_columns< ::Bug, id_pgsql, A >::
  max_liveness (A::table_name, "\"max_liveness\"", 0);

  template <typename A>
  const typename query_columns< ::Bug, id_pgsql, A >::extra_duas_type_
  query_columns< ::Bug, id_pgsql, A >::
  extra_duas (A::table_name, "\"extra_duas\"", "(?)::BIGINT[]");

  template <typename A>
  const typename query_columns< ::Bug, id_pgsql, A >::magic_type_
  query_columns< ::Bug, id_pgsql, A >::
  magic (A::table_name, "\"magic\"", 0);

  // BugLval
  //
  struct access::view_traits_impl< ::BugLval, id_pgsql >::query_columns:
    odb::pointer_query_columns<
      ::Bug,
      id_pgsql,
      odb::access::object_traits_impl< ::Bug, id_pgsql > >
  {
  };

  // Build
  //
  // Run
  //
  template <>
  struct alias_traits<
    ::Build,
    id_pgsql,
    access::object_traits_impl< ::Run, id_pgsql >::build_tag>
  {
    static const char table_name[];
  };

  template <>
  struct alias_traits<
    ::Bug,
    id_pgsql,
    access::object_traits_impl< ::Run, id_pgsql >::fuzzed_tag>
  {
    static const char table_name[];
  };

  template <>
  struct query_columns_base< ::Run, id_pgsql >
  {
    // build
    //
    typedef
    odb::alias_traits<
      ::Build,
      id_pgsql,
      access::object_traits_impl< ::Run, id_pgsql >::build_tag>
    build_alias_;

    // fuzzed
    //
    typedef
    odb::alias_traits<
      ::Bug,
      id_pgsql,
      access::object_traits_impl< ::Run, id_pgsql >::fuzzed_tag>
    fuzzed_alias_;
  };

  template <typename A>
  struct query_columns< ::Run, id_pgsql, A >:
    query_columns_base< ::Run, id_pgsql >
  {
    // id
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint64_t,
        pgsql::id_bigint >::query_type,
      pgsql::id_bigint >
    id_type_;

    static const id_type_ id;

    // build
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint64_t,
        pgsql::id_bigint >::query_type,
      pgsql::id_bigint >
    build_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::Build,
        id_pgsql,
        build_alias_ > >
    build_pointer_type_;

    struct build_type_: build_pointer_type_, build_column_type_
    {
      build_type_ (const char* t, const char* c, const char* conv)
        : build_column_type_ (t, c, conv)
      {
      }
    };

    static const build_type_ build;

    // fuzzed
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint64_t,
        pgsql::id_bigint >::query_type,
      pgsql::id_bigint >
    fuzzed_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::Bug,
        id_pgsql,
        fuzzed_alias_ > >
    fuzzed_pointer_type_;

    struct fuzzed_type_: fuzzed_pointer_type_, fuzzed_column_type_
    {
      fuzzed_type_ (const char* t, const char* c, const char* conv)
        : fuzzed_column_type_ (t, c, conv)
      {
      }
    };

    static const fuzzed_type_ fuzzed;

    // exitcode
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        int,
        pgsql::id_integer >::query_type,
      pgsql::id_integer >
    exitcode_type_;

    static const exitcode_type_ exitcode;

    // output
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::std::string,
        pgsql::id_string >::query_type,
      pgsql::id_string >
    output_type_;

    static const output_type_ output;

    // success
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        bool,
        pgsql::id_boolean >::query_type,
      pgsql::id_boolean >
    success_type_;

    static const success_type_ success;

    // validated
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        bool,
        pgsql::id_boolean >::query_type,
      pgsql::id_boolean >
    validated_type_;

    static const validated_type_ validated;
  };

  template <typename A>
  const typename query_columns< ::Run, id_pgsql, A >::id_type_
  query_columns< ::Run, id_pgsql, A >::
  id (A::table_name, "\"id\"", 0);

  template <typename A>
  const typename query_columns< ::Run, id_pgsql, A >::build_type_
  query_columns< ::Run, id_pgsql, A >::
  build (A::table_name, "\"build\"", 0);

  template <typename A>
  const typename query_columns< ::Run, id_pgsql, A >::fuzzed_type_
  query_columns< ::Run, id_pgsql, A >::
  fuzzed (A::table_name, "\"fuzzed\"", 0);

  template <typename A>
  const typename query_columns< ::Run, id_pgsql, A >::exitcode_type_
  query_columns< ::Run, id_pgsql, A >::
  exitcode (A::table_name, "\"exitcode\"", 0);

  template <typename A>
  const typename query_columns< ::Run, id_pgsql, A >::output_type_
  query_columns< ::Run, id_pgsql, A >::
  output (A::table_name, "\"output\"", 0);

  template <typename A>
  const typename query_columns< ::Run, id_pgsql, A >::success_type_
  query_columns< ::Run, id_pgsql, A >::
  success (A::table_name, "\"success\"", 0);

  template <typename A>
  const typename query_columns< ::Run, id_pgsql, A >::validated_type_
  query_columns< ::Run, id_pgsql, A >::
  validated (A::table_name, "\"validated\"", 0);

  // SourceFunction
  //
  // Call
  //
  template <>
  struct alias_traits<
    ::SourceFunction,
    id_pgsql,
    access::object_traits_impl< ::Call, id_pgsql >::called_function_tag>
  {
    static const char table_name[];
  };

  template <>
  struct query_columns_base< ::Call, id_pgsql >
  {
    // called_function
    //
    typedef
    odb::alias_traits<
      ::SourceFunction,
      id_pgsql,
      access::object_traits_impl< ::Call, id_pgsql >::called_function_tag>
    called_function_alias_;
  };

  template <typename A>
  struct query_columns< ::Call, id_pgsql, A >:
    query_columns_base< ::Call, id_pgsql >
  {
    // id
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint64_t,
        pgsql::id_bigint >::query_type,
      pgsql::id_bigint >
    id_type_;

    static const id_type_ id;

    // call_instr
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint64_t,
        pgsql::id_bigint >::query_type,
      pgsql::id_bigint >
    call_instr_type_;

    static const call_instr_type_ call_instr;

    // ret_instr
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint64_t,
        pgsql::id_bigint >::query_type,
      pgsql::id_bigint >
    ret_instr_type_;

    static const ret_instr_type_ ret_instr;

    // called_function
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint64_t,
        pgsql::id_bigint >::query_type,
      pgsql::id_bigint >
    called_function_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::SourceFunction,
        id_pgsql,
        called_function_alias_ > >
    called_function_pointer_type_;

    struct called_function_type_: called_function_pointer_type_, called_function_column_type_
    {
      called_function_type_ (const char* t, const char* c, const char* conv)
        : called_function_column_type_ (t, c, conv)
      {
      }
    };

    static const called_function_type_ called_function;

    // callsite_file
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::std::string,
        pgsql::id_string >::query_type,
      pgsql::id_string >
    callsite_file_type_;

    static const callsite_file_type_ callsite_file;

    // callsite_line
    //
    typedef
    pgsql::query_column<
      pgsql::value_traits<
        ::uint32_t,
        pgsql::id_integer >::query_type,
      pgsql::id_integer >
    callsite_line_type_;

    static const callsite_line_type_ callsite_line;
  };

  template <typename A>
  const typename query_columns< ::Call, id_pgsql, A >::id_type_
  query_columns< ::Call, id_pgsql, A >::
  id (A::table_name, "\"id\"", 0);

  template <typename A>
  const typename query_columns< ::Call, id_pgsql, A >::call_instr_type_
  query_columns< ::Call, id_pgsql, A >::
  call_instr (A::table_name, "\"call_instr\"", 0);

  template <typename A>
  const typename query_columns< ::Call, id_pgsql, A >::ret_instr_type_
  query_columns< ::Call, id_pgsql, A >::
  ret_instr (A::table_name, "\"ret_instr\"", 0);

  template <typename A>
  const typename query_columns< ::Call, id_pgsql, A >::called_function_type_
  query_columns< ::Call, id_pgsql, A >::
  called_function (A::table_name, "\"called_function\"", 0);

  template <typename A>
  const typename query_columns< ::Call, id_pgsql, A >::callsite_file_type_
  query_columns< ::Call, id_pgsql, A >::
  callsite_file (A::table_name, "\"callsite_file\"", 0);

  template <typename A>
  const typename query_columns< ::Call, id_pgsql, A >::callsite_line_type_
  query_columns< ::Call, id_pgsql, A >::
  callsite_line (A::table_name, "\"callsite_line\"", 0);
}

#include "lava-odb.ixx"

#include <odb/post.hxx>

#endif // LAVA_ODB_HXX
